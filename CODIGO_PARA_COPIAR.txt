// ============================================
// INSTRUCCIONES PARA IMPLEMENTAR MANUALMENTE
// ============================================

// PASO 1: Agregar import despu√©s de la l√≠nea 2
// Agrega esta l√≠nea despu√©s de: import { logService } from './logService'

import { productService } from './productService'


// PASO 2: Agregar este m√©todo ANTES del m√©todo markOrderAsPaid (antes de la l√≠nea 557)
// Insertarlo despu√©s del m√©todo getOrderById

  /**
   * ‚úÖ FASE 1: Validar disponibilidad de stock para los items de una orden
   * Valida que haya stock suficiente ANTES de aprobar el pago
   */
  async validateStockAvailability(items: Array<{product_id: string, quantity: number, product_name?: string}>): Promise<{
    valid: boolean
    message?: string
    insufficientItems?: Array<{product_id: string, product_name: string, requested: number, available: number}>
  }> {
    try {
      const insufficientItems = []
      
      console.log('üîç Validando stock para', items.length, 'productos...')
      
      for (const item of items) {
        const product = await productService.getProductById(item.product_id)
        
        if (!product) {
          console.error('‚ùå Producto no encontrado:', item.product_id)
          return {
            valid: false,
            message: `Producto con ID ${item.product_id} no encontrado`
          }
        }
        
        console.log(`  - ${product.name}: ${product.stock} disponible, ${item.quantity} solicitado`)
        
        if (product.stock < item.quantity) {
          insufficientItems.push({
            product_id: item.product_id,
            product_name: product.name,
            requested: item.quantity,
            available: product.stock
          })
        }
      }
      
      if (insufficientItems.length > 0) {
        const details = insufficientItems
          .map(i => `${i.product_name}: solicitado ${i.requested}, disponible ${i.available}`)
          .join(', ')
        
        console.error('‚ùå Stock insuficiente:', details)
        
        return {
          valid: false,
          message: `Stock insuficiente para: ${details}`,
          insufficientItems
        }
      }
      
      console.log('‚úÖ Validaci√≥n de stock exitosa')
      return { valid: true }
      
    } catch (error) {
      console.error('‚ùå Error validando stock:', error)
      return {
        valid: false,
        message: 'Error al validar disponibilidad de stock'
      }
    }
  },


// PASO 3: REEMPLAZAR TODO el m√©todo markOrderAsPaid (l√≠neas 557-618) con este c√≥digo:

  /**
   * ‚úÖ FASE 1: Marcar orden como pagada y REDUCIR STOCK
   * Ahora incluye validaci√≥n de stock y reducci√≥n autom√°tica
   */
  async markOrderAsPaid(orderId: string, paymentInfo: {
    payment_id: string
    metodo_pago: string
    fecha_pago: string
    comprobante_url?: string
    fulfillment_status?: string
  }): Promise<Order> {
    try {
      console.log('üí∞ Marcando orden como pagada:', orderId)
      
      // ‚úÖ PASO 1: Obtener la orden completa con sus items
      const order = await this.getOrderById(orderId)
      if (!order) {
        throw new Error('Orden no encontrada')
      }
      
      console.log('üì¶ Orden encontrada con', order.items?.length || 0, 'items')
      
      // ‚úÖ PASO 2: VALIDAR STOCK ANTES DE APROBAR (FASE 1)
      console.log('üîç Validando disponibilidad de stock...')
      const stockValidation = await this.validateStockAvailability(order.items || [])
      
      if (!stockValidation.valid) {
        const errorMsg = `Stock insuficiente: ${stockValidation.message}`
        console.error('‚ùå', errorMsg)
        
        // Log de error para debugging
        await logService.recordActivity({
          action: 'order_payment_rejected_insufficient_stock',
          entity_type: 'order',
          entity_id: orderId,
          details: {
            payment_id: paymentInfo.payment_id,
            validation_result: stockValidation,
            error: errorMsg
          }
        })
        
        throw new Error(errorMsg)
      }
      
      console.log('‚úÖ Stock validado correctamente')
      
      // ‚úÖ PASO 3: Actualizar payment_status en la BD
      const updateData: any = {
        payment_status: 'approved',
        status: 'confirmed',
        payment_id: paymentInfo.payment_id,
        metodo_pago: paymentInfo.metodo_pago,
        fecha_pago: paymentInfo.fecha_pago,
        comprobante_url: paymentInfo.comprobante_url,
        updated_at: new Date().toISOString()
      }

      if (paymentInfo.fulfillment_status) {
        updateData.fulfillment_status = paymentInfo.fulfillment_status
      }

      const { data, error } = await supabase
        .from('orders')
        .update(updateData)
        .eq('id', orderId)
        .select('*')
        .single()

      if (error) {
        console.error('‚ùå Error actualizando orden:', error)
        throw new Error('Error al marcar orden como pagada')
      }

      console.log('‚úÖ Orden actualizada en BD')

      // ‚úÖ PASO 4: REDUCIR STOCK DE PRODUCTOS (FASE 1)
      console.log('üìâ Reduciendo stock de productos...')
      const stockReductionErrors = []
      
      try {
        for (const item of order.items || []) {
          console.log(`  - Reduciendo ${item.quantity} unidades de ${item.product_name || item.product_id}`)
          
          const success = await productService.updateStock(item.product_id, item.quantity)
          
          if (!success) {
            stockReductionErrors.push({
              product_id: item.product_id,
              product_name: item.product_name || 'Producto',
              quantity: item.quantity
            })
          }
        }
        
        if (stockReduction Errors.length > 0) {
          console.error('‚ö†Ô∏è Algunos productos no pudieron actualizar stock:', stockReductionErrors)
          
          // Log para debugging (NO fallar la orden, solo registrar)
          await logService.recordActivity({
            action: 'stock_reduction_partial_failure',
            entity_type: 'order',
            entity_id: orderId,
            details: {
              failed_products: stockReductionErrors,
              payment_id: paymentInfo.payment_id
            }
          })
        } else {
          console.log('‚úÖ Stock reducido exitosamente para todos los productos')
        }
      } catch (stockError) {
        console.error('‚ùå Error reduciendo stock:', stockError)
        
        // Log del error pero NO fallar la orden (ya fue pagada)
        await logService.recordActivity({
          action: 'stock_reduction_error',
          entity_type: 'order',
          entity_id: orderId,
          details: {
            error: stockError instanceof Error ? stockError.message : 'Error desconocido',
            payment_id: paymentInfo.payment_id,
            // TODO FASE 2: Implementar rollback manual si es cr√≠tico
          }
        })
      }

      // Registrar actividad de pago aprobado
      await logService.recordActivity({
        action: 'order_paid',
        entity_type: 'order',
        entity_id: orderId,
        details: {
          payment_id: paymentInfo.payment_id,
          metodo_pago: paymentInfo.metodo_pago,
          fecha_pago: paymentInfo.fecha_pago,
          previous_status: 'pending',
          new_status: 'confirmed',
          stock_reduced: stockReductionErrors.length === 0
        }
      })

      // Obtener orden completa actualizada
      const fullOrder = await this.getOrderById(orderId)
      if (!fullOrder) {
        throw new Error('Orden no encontrada despu√©s de marcar como pagada')
      }
      
      console.log('‚úÖ Orden marcada como pagada exitosamente')
      return fullOrder

    } catch (error) {
      console.error('‚ùå Error in markOrderAsPaid:', error)
      throw error
    }
  },
